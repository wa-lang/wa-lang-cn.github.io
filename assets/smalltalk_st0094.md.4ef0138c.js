import{_ as t,c as e,o as r,a as n}from"./app.9a9f499d.js";const s="/st0094-01.jpg",l="/st0094-02.png",u=JSON.parse('{"title":"凹语言中文版NOIP 2024真题详解第1题","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. NOIP 2024 第1题","slug":"_1-noip-2024-第1题","link":"#_1-noip-2024-第1题","children":[]},{"level":2,"title":"2. 💡 最易理解的算法：纯粹的贪心与计数","slug":"_2-💡-最易理解的算法-纯粹的贪心与计数","link":"#_2-💡-最易理解的算法-纯粹的贪心与计数","children":[{"level":3,"title":"2.1. 核心洞察：字符的分类与自由度","slug":"_2-1-核心洞察-字符的分类与自由度","link":"#_2-1-核心洞察-字符的分类与自由度","children":[]},{"level":3,"title":"2.2. 算法核心：两个独立的池子","slug":"_2-2-算法核心-两个独立的池子","link":"#_2-2-算法核心-两个独立的池子","children":[]},{"level":3,"title":"2.3. 三步贪心策略","slug":"_2-3-三步贪心策略","link":"#_2-3-三步贪心策略","children":[]}]},{"level":2,"title":"3. 开始解决正题","slug":"_3-开始解决正题","link":"#_3-开始解决正题","children":[]},{"level":2,"title":"4. 结语：在实战中打磨中文编程","slug":"_4-结语-在实战中打磨中文编程","link":"#_4-结语-在实战中打磨中文编程","children":[]}],"relativePath":"smalltalk/st0094.md"}'),i={name:"smalltalk/st0094.md"},a=n('<h1 id="凹语言中文版noip-2024真题详解第1题" tabindex="-1">凹语言中文版NOIP 2024真题详解第1题 <a class="header-anchor" href="#凹语言中文版noip-2024真题详解第1题" aria-hidden="true">#</a></h1><ul><li>时间：2025-11-12</li><li>撰稿：凹语言开发组</li><li>转载请注明原文链接：<a href="https://wa-lang.org/smalltalk/st0094.html" target="_blank" rel="noreferrer">https://wa-lang.org/smalltalk/st0094.html</a></li></ul><hr><p>NOIP 是全国青少年信息学奥林匹克联赛的英文缩写，是面向中小学生的信息学竞赛。由中国计算机学会主办，是国内信息学领域权威的普及性竞赛。主要考察编程能力和算法思维，核心语言包括 C++（主流）、C、Pascal（部分组别）。参赛对象为小学、初中、高中学生，分提高组、普及组等组别。成绩优秀者可获得高校自主招生、综合评价等相关优惠，是信息学特长升学的重要参考。</p><p>作为中国乃至面向世界的赛事，NOIP 比赛使用的全部是国外的编程语言。本文尝试通过凹语言来讲解答，通过不同的视角体会算法问题和工程问题的差异。</p><h2 id="_1-noip-2024-第1题" tabindex="-1">1. NOIP 2024 第1题 <a class="header-anchor" href="#_1-noip-2024-第1题" aria-hidden="true">#</a></h2><p><img src="'+s+'" alt=""></p><p>如果暂时不考虑性能（即 $O(n^2)$ 甚至更慢的复杂度也没关系），我们能找到一个<strong>更直观、更容易理解</strong>的算法，这个算法被称为<strong>最大流/最小费用最大流</strong>模型，或者用更简单的语言描述：<strong>最大二分图匹配</strong>的变形。</p><p>但是，因为这个题目的特殊性质（只有 &#39;0&#39; 和 &#39;1&#39; 两种字符，且操作是相邻交换），我们可以避开复杂的图论模型，直接使用<strong>纯粹的贪心和计数</strong>，这是最容易理解且最高效的方法。</p><h2 id="_2-💡-最易理解的算法-纯粹的贪心与计数" tabindex="-1">2. 💡 最易理解的算法：纯粹的贪心与计数 <a class="header-anchor" href="#_2-💡-最易理解的算法-纯粹的贪心与计数" aria-hidden="true">#</a></h2><p>这个算法的思路是：<strong>将问题分解为独立的两部分，并分别用贪心法解决。</strong></p><h3 id="_2-1-核心洞察-字符的分类与自由度" tabindex="-1">2.1. 核心洞察：字符的分类与自由度 <a class="header-anchor" href="#_2-1-核心洞察-字符的分类与自由度" aria-hidden="true">#</a></h3><p>所有的字符和位置都可以根据它们能否被交换，被分成四种类型：</p><table><thead><tr><th style="text-align:center;">$s_1$ 的状态 ($t_{1,i}$)</th><th style="text-align:center;">$s_2$ 的状态 ($t_{2,i}$)</th><th style="text-align:center;">位置 $i$ 的自由度</th><th style="text-align:center;">决策：匹配 $s_{1,i}$ 和 $s_{2,i}$</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>0 (固定)</strong></td><td style="text-align:center;"><strong>0 (固定)</strong></td><td style="text-align:center;">0</td><td style="text-align:center;"><strong>固定匹配/不匹配。</strong> $s_{1,i}$ 必须对 $s_{2,i}$。</td></tr><tr><td style="text-align:center;"><strong>0 (固定)</strong></td><td style="text-align:center;"><strong>1 (可换)</strong></td><td style="text-align:center;">1</td><td style="text-align:center;">$s_{1,i}$ 确定。用 $s_2$ 的<strong>可换字符池</strong>去匹配它。</td></tr><tr><td style="text-align:center;"><strong>1 (可换)</strong></td><td style="text-align:center;"><strong>0 (固定)</strong></td><td style="text-align:center;">1</td><td style="text-align:center;">$s_{2,i}$ 确定。用 $s_1$ 的<strong>可换字符池</strong>去匹配它。</td></tr><tr><td style="text-align:center;"><strong>1 (可换)</strong></td><td style="text-align:center;"><strong>1 (可换)</strong></td><td style="text-align:center;">2</td><td style="text-align:center;"><strong>完全自由。</strong> 用 $s_1, s_2$ <strong>剩余</strong>的字符池进行自由组合。</td></tr></tbody></table><h3 id="_2-2-算法核心-两个独立的池子" tabindex="-1">2.2. 算法核心：两个独立的池子 <a class="header-anchor" href="#_2-2-算法核心-两个独立的池子" aria-hidden="true">#</a></h3><p>因为相邻交换的特性（只要没有 $t_{i}=0$ 的障碍物，可换字符可以在其区间内任意排列），我们可以把所有 $t_{1,i}=1$ 的字符<strong>想象成一个大池子 $C_1$</strong>，所有 $t_{2,i}=1$ 的字符<strong>想象成一个大池子 $C_2$</strong>。</p><p><strong>目标：</strong> 最大化从 $C_1$ 和 $C_2$ 中取出相同字符进行匹配的次数。</p><h3 id="_2-3-三步贪心策略" tabindex="-1">2.3. 三步贪心策略 <a class="header-anchor" href="#_2-3-三步贪心策略" aria-hidden="true">#</a></h3><p>我们将匹配过程分为三步，每一步都采用贪心策略，因为一旦完成了匹配，这个字符就不能再被使用了（即：<strong>先用先得</strong>）。</p><h4 id="步骤-1-处理双固定的位置-类型-0" tabindex="-1">步骤 1：处理双固定的位置（类型 0） <a class="header-anchor" href="#步骤-1-处理双固定的位置-类型-0" aria-hidden="true">#</a></h4><ul><li><strong>操作：</strong> 遍历所有 $i$，如果 $t_{1,i}=0$ 且 $t_{2,i}=0$。</li><li><strong>贪心：</strong> 如果 $s_{1,i} = s_{2,i}$，这是一个<strong>确定无疑的匹配</strong>。</li><li><strong>效果：</strong> 答案 $+1$。</li></ul><h4 id="步骤-2-处理一固一换的位置-类型-1" tabindex="-1">步骤 2：处理一固一换的位置（类型 1） <a class="header-anchor" href="#步骤-2-处理一固一换的位置-类型-1" aria-hidden="true">#</a></h4><ul><li><strong>操作：</strong> 遍历所有 $i$ 属于类型 1 的位置（$t_{1,i} \\neq t_{2,i}$）。</li><li><strong>贪心：</strong> 在这类位置上，我们必须用 $s_1$ 或 $s_2$ 中固定的字符去<strong>锁定</strong>匹配目标，然后<strong>消耗</strong>掉另一个字符串的字符池中的一个对应字符。 <ul><li><strong>例：</strong> $t_{1,i}=0, t_{2,i}=1$ 且 $s_{1,i} = &#39;0&#39;$。如果 $C_2$ 池子中还有 &#39;0&#39;，我们<strong>必须</strong>用 $C_2$ 中的一个 &#39;0&#39; 来匹配这个固定的 $s_{1,i}$，从而锁定这个匹配。</li></ul></li><li><strong>效果：</strong><ul><li>如果匹配成功，答案 $+1$。</li><li>相应地，从 $C_1$ 或 $C_2$ 中<strong>减少</strong>对应字符的计数。</li></ul></li></ul><p><strong>为什么先处理这个？</strong> 因为这些固定字符是<strong>必须</strong>要匹配的（如果可能），它们消耗了 $C_1$ 或 $C_2$ 的资源，限制了接下来的自由组合。</p><h4 id="步骤-3-处理双可换的位置-类型-2" tabindex="-1">步骤 3：处理双可换的位置（类型 2） <a class="header-anchor" href="#步骤-3-处理双可换的位置-类型-2" aria-hidden="true">#</a></h4><ul><li><strong>操作：</strong> 此时 $C_1$ 和 $C_2$ 池子中还剩下一些字符，以及一些 $t_{1,i}=1, t_{2,i}=1$ 的<strong>空闲位置</strong>。</li><li><strong>贪心：</strong> 由于这些空闲位置是完全自由的，我们可以用 $C_1$ 中<strong>剩余</strong>的字符和 $C_2$ 中<strong>剩余</strong>的字符进行<strong>最大化匹配</strong>。 <ul><li><strong>匹配 &#39;0&#39;：</strong> 我们可以组成 $\\min(\\text{剩余 &#39;0&#39; in } C_1, \\text{剩余 &#39;0&#39; in } C_2)$ 对。</li><li><strong>匹配 &#39;1&#39;：</strong> 我们可以组成 $\\min(\\text{剩余 &#39;1&#39; in } C_1, \\text{剩余 &#39;1&#39; in } C_2)$ 对。</li></ul></li><li><strong>效果：</strong> 答案加上这些匹配的总和。</li></ul><h2 id="_3-开始解决正题" tabindex="-1">3. 开始解决正题 <a class="header-anchor" href="#_3-开始解决正题" aria-hidden="true">#</a></h2><p>这个算法把一个复杂的排列问题，简化成了<strong>资源分配</strong>问题：</p><ol><li><strong>确定</strong>不需要资源的匹配。</li><li><strong>贪心</strong>分配资源（$C_1$ 和 $C_2$）给那些半固定的需求。</li><li><strong>最大化</strong>利用剩余的资源进行自由组合。</li></ol><p>由于我们总是在可能的情况下优先匹配（贪心），且我们没有丢失任何字符（$C_1$ 和 $C_2$ 中包含了所有可换字符），这个策略是正确的。</p><p>凹语言中文编程的代码片段如下：</p><p><img src="'+l+'" alt=""></p><p>完整的代码：<a href="https://gitcode.com/wa-lang/wa/blob/master/waroot/examples/noip2024/edit.wz" target="_blank" rel="noreferrer">https://gitcode.com/wa-lang/wa/blob/master/waroot/examples/noip2024/edit.wz</a></p><h2 id="_4-结语-在实战中打磨中文编程" tabindex="-1">4. 结语：在实战中打磨中文编程 <a class="header-anchor" href="#_4-结语-在实战中打磨中文编程" aria-hidden="true">#</a></h2><p>之前我们已经通过凹语言中文编程展示了CSP-J题目的解法，今天我们更进一步给出了NOIP题目的解法。正如我国回归联合国的过程充满了曲折，中文编程想走向世界的道路也注定不会平坦。最终的结果是汉语成了联合国的官方工作语言之一，中文编程也必将在世界上占有一席之地。</p>',35),o=[a];function g(d,_,$,h,c,p){return r(),e("div",null,o)}const C=t(i,[["render",g]]);export{u as __pageData,C as default};
